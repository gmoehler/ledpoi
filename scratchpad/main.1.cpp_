/* GPIO Example

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/

#include <Arduino.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"

#include "ledpoi.h"
#include "PoiCommand.h"
#include "button.h"
#include "wifi.h"
#include "ws2812.h"

/**
 * Brief:
 * Detect button clicks and longclicks and send it to a queue.
 *
 * GPIO status:
 * GPIO0:  input, pulled up, interrupt from rising edge and falling edge
 *
 * Test:
 * Press GPIO0, this triggers interrupt
 *
 */

xQueueHandle commandQueue = NULL;
xQueueHandle frameQueue = NULL;

volatile SemaphoreHandle_t frameTimerSemaphore;
hw_timer_t * frameTimer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

const int DATA_PIN = 23; // was 18 Avoid using any of the strapping pins on the ESP32
rgbVal pixels[N_PIXELS];
uint8_t MAX_COLOR_VAL = 32; // Limits brightness

bool toggle = true;

// fill frame (frame has been allocated before with size N_PIXELS)
static void fillFrame(uint8_t r, uint8_t g, uint8_t b){
  for(uint8_t i=0; i<N_PIXELS; i++) {
    pixels[i] = makeRGBVal(r,g,b);
  } 
}


static void playToggle(){
  for(uint16_t i=0; i<N_PIXELS; i++) {
    if (toggle) {
      pixels[i] = makeRGBVal(MAX_COLOR_VAL,0,0);
    } 
    else { 
      pixels[i] = makeRGBVal(0, MAX_COLOR_VAL,0);
    }
  }
  toggle = !toggle;
  ws2812_setColors(N_PIXELS, pixels);
}

// reads from command queue
static void adminTask(void* arg)
{
  PoiCommand cmd;

    for(;;) {
      if(xQueueReceive(commandQueue, &cmd, portMAX_DELAY)) {
      uint8_t* a = cmd.getArgs();  

      switch (cmd.getType()){   
        case BUTTON0_CLICK :
          printf("--> CLICK\n");
          break;
        
        case BUTTON0_LONGCLICK :
          printf("--> LONG CLICK\n");
          break;
          
        case BUTTON0_RELEASE:
          printf("--> BUTTON RELEASED\n");
          break;
        
        case PLAY_CMD:
          printf("--> PLAY %d %d %d %d %d %d \n", a[0], a[1], a[2], a[3], a[4], a[5]);
          break;

        default:
          printf("--> UNKNOWN BUTTON EVENT: %d\n", static_cast<int>(cmd.getType()));
      }
    }
  }
}


void IRAM_ATTR onFrameTimer(){
  // Increment the counter and set the time of ISR
  portENTER_CRITICAL_ISR(&timerMux);
  // nothing critical for now
  portEXIT_CRITICAL_ISR(&timerMux);
  // Give a semaphore that we can check in the loop
  xSemaphoreGiveFromISR(frameTimerSemaphore, NULL);
  // It is safe to use digitalRead/Write here if you want to toggle an output
}

static void playTask(void* arg)
{
  rgbVal frame[N_PIXELS];

  for(;;) {
    //printf(".\n");
    if (xSemaphoreTake(frameTimerSemaphore, portMAX_DELAY)) {
      // printf("Playing...\n");
      if(xQueueReceive(frameQueue, &frame, portMAX_DELAY)) {
        //printf("Frame received: %d %d %d\n", frame[0].r, frame[0].g, frame[0].b);
        ws2812_setColors(N_PIXELS, frame);
      }
      //printf with ws2812_setColors causes problems here
      // playToggle();
    }
  }
}


void setup()
{
  buttonSetup();

  //create a queue to handle button commands from isr
  commandQueue = xQueueCreate(1, sizeof(PoiCommand));
  //start button task
  xTaskCreate(adminTask, "adminTask", 2048, NULL, 1, NULL);
  xTaskCreate(wifiTask, "wifiTask", 2048, NULL, 1, NULL);

  frameQueue = xQueueCreate(3, sizeof(N_PIXELS * sizeof(rgbVal)));

  if(ws2812_init(DATA_PIN, LED_WS2812B)){
    Serial.println("LED Pixel init error.");
  }
   ws2812_setColors(N_PIXELS, pixels);
  // pixels = (rgbVal*)malloc(sizeof(rgbVal) * N_PIXELS);

  // send 3 frames to the play queue
  fillFrame(0, 0, MAX_COLOR_VAL);
  ws2812_setColors(N_PIXELS, pixels);
  printf("Frame sent: %d %d %d\n", pixels[0].r, pixels[0].g, pixels[0].b);
  if (xQueueSendToBack(frameQueue, &pixels, 100/portTICK_PERIOD_MS) != pdTRUE){
    printf("Could not add frame 1 to queue\n");
  }
  fillFrame(0, MAX_COLOR_VAL, 0);
  printf("Frame 2 sent: %d %d %d\n", pixels[0].r, pixels[0].g, pixels[0].b);
  if (xQueueSendToBack(frameQueue, &pixels, 100/portTICK_PERIOD_MS) != pdTRUE){
    printf("Could not add frame 2 to queue\n");
  }
  fillFrame(0, 0, MAX_COLOR_VAL);
  printf("Frame 3 sent: %d %d %d\n", pixels[0].r, pixels[0].g, pixels[0].b);
  if (xQueueSendToBack(frameQueue, &pixels, 100/portTICK_PERIOD_MS) != pdTRUE){
    printf("Could not add frame 3 to queue\n");
  }


  // create and start frame timer and task
  frameTimerSemaphore = xSemaphoreCreateBinary();
  frameTimer = timerBegin(3, 80, true); // start timer 0 counting up
  timerAttachInterrupt(frameTimer, &onFrameTimer, true);
  timerAlarmWrite(frameTimer, 1000000, true); // time in millisecs
  timerAlarmEnable(frameTimer);
  xTaskCreate(playTask, "playTask", 4096, NULL, 1, NULL);
  
}

void loop(){
  delay(100000);
}